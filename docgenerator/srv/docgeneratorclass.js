// generate-docx.js
// Node.js class that generates a stylish Word (.docx) document from a payload or an array of payloads
// Uses the `docx` package (https://www.npmjs.com/package/docx)
// Usage:
//   npm install docx
//   node generate-docx.js

const fs = require("fs");
const path = require("path");
const { saveAs } = require("file-saver");
const {
  Document,
  Packer,
  Paragraph,
  TextRun,
  Table,
  TableRow,
  TableCell,
  WidthType,
  HeadingLevel,
  AlignmentType,
  BorderStyle,
  Footer,
  PageNumber,
  TableOfContents
} = require("docx");

/**
 * Class: DocGenerator
 * - Accepts either a single payload object or an array of payload objects
 * - Can generate a single combined document (each item starts on a new page)
 * - Can generate separate documents (one file per item)
 *
 * Example:
 *   const gen = new DocGenerator([payload1, payload2]);
 *   await gen.generateCombined('all.docx');
 *   await gen.generateSeparate('./out-dir');
 */

class TemplateDocgenerator {
  
   constructor(options = {}) {
    this.options = options;
    // default styles can be extended
    this.titleStyle = { size: 28, bold: true };
    this.headingStyle = { size: 20, bold: true };
    this.normalStyle = { size: 22 };
    this.payload = options.payload || {};
    this.creator = options.creator || "Autogenerated by DocGenerator";
  }

  /**
   * Create paragraphs for a block of text (split by newlines)
   */
  _textBlockParagraphs(text) {
    if (!text) return [];
    return String(text).split(/\r?\n/).map(line =>
      new Paragraph({
        children: [new TextRun({ text: line || "", size: this.normalStyle.size })],
      })
    );
  }

  /**
   * Helper to create heading paragraphs
   */
  _heading(text, level = 1) {
    const headingLevel = level === 1 ? HeadingLevel.HEADING_1 : (level === 2 ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3);
    return new Paragraph({
      text: text || "",
      heading: headingLevel,
    });
  }

  /**
   * Build a simple two-column property table for Project Identification / Revision history etc.
   * rows: array of {label: string, value: string}
   */
  _buildPropertyTable(rows = []) {
    const tableRows = rows.map(r =>
      new TableRow({
        children: [
          new TableCell({
            width: { size: 30, type: WidthType.PERCENTAGE },
            children: [new Paragraph({ text: r.label || "", bold: true })],
          }),
          new TableCell({
            width: { size: 70, type: WidthType.PERCENTAGE },
            children: this._textBlockParagraphs(r.value || ""),
          }),
        ],
      })
    );

    return new Table({
      width: { size: 100, type: WidthType.PERCENTAGE },
      rows: tableRows,
    });
  }

  /**
   * Main generate function
   * @param {Object} data - JSON input
   * @param {string} outputPath - file path to write .docx
   * @returns {Promise<Buffer>} - resolves to buffer (also writes to file if outputPath provided)
   */
  async generate(data = {}, outputPath = null) {
    // Document sections based on uploaded template structure.
    const sections = [{properties:{},children:[]}];
    
    
    //console.log(doc.sections);
    
    // Convenience
    const c = sections[0].children;
    //Table of Contents
    c.push(new Paragraph({
      text: "Table of Contents",
      heading: HeadingLevel.HEADING_1,
      alignment: AlignmentType.CENTER,
      spacing: { after: 300 },
    }));
    c.push(new Paragraph({
      children: [new TableOfContents("Table of Contents", {
        headingStyleRange: "1-3",
        hyperlink: true,
        sequenceAndPageNumbersSeparator: new TextRun({ text: " . " })
      })],
      spacing: { after: 300 }
    }));
    c.push(new Paragraph({ text: "" }));  
    // Title block (project + customer)
    const projectName = data.projectName || "< Project Name >";
    const customerName = data.customerName || "< Customer Name >";
    c.push(
      new Paragraph({
        children: [
          new TextRun({ text: "Project Functional Specification Document", bold: true, size: 36 }),
        ],
        alignment: AlignmentType.CENTER,
      }),
      new Paragraph({ text: "" }),
      new Paragraph({ children: [ new TextRun({ text: `Project Name: ${projectName}`, bold: true }) ] }),
      new Paragraph({ children: [ new TextRun({ text: `Customer Name: ${customerName}`, bold: true }) ] }),
      new Paragraph({ text: "" })
    );

    // Add a simple "Project Identification" table if provided
    if (data.projectIdentification) {
      c.push(this._heading("Project Identification", 2));
      const rows = [];
      for (const item of data.projectIdentification) {
        rows.push({ label: item.label, value: item.value });
      }
      if (rows.length === 0) {
        rows.push({ label: "Project Name", value: projectName });
        rows.push({ label: "Customer Name", value: customerName });
      }
      c.push(this._buildPropertyTable(rows));
    }

    // Revision history
    if (data.revisionHistory && data.revisionHistory.length) {
      c.push(this._heading("Revision history", 2));
      // Build a table with columns: Author | Version | Date | Status | Location
      const headerRow = new TableRow({
        children: ["Author", "Version", "Date", "Status", "Document Location"].map(h =>
          new TableCell({ children: [new Paragraph({ text: h, bold: true })] })
        ),
      });

      const revRows = data.revisionHistory.map(r => new TableRow({
        children: [
          new TableCell({ children: this._textBlockParagraphs(r.author || "") }),
          new TableCell({ children: this._textBlockParagraphs(r.version || "") }),
          new TableCell({ children: this._textBlockParagraphs(r.date || "") }),
          new TableCell({ children: this._textBlockParagraphs(r.status || "") }),
          new TableCell({ children: this._textBlockParagraphs(r.location || "") }),
        ],
      }));

      const revTable = new Table({
        rows: [headerRow, ...revRows],
        width: { size: 100, type: WidthType.PERCENTAGE },
      });
      c.push(revTable);
    }

    // Overview section and sub-sections
    c.push(this._heading("1. Overview", 2));
    const overviewSections = [
      { title: "a. Business Process Overview", key: "businessProcessOverview" },
      { title: "b. Functional Overview", key: "functionalOverview" },
      { title: "c. Alternatives Considered", key: "alternativesConsidered" },
      { title: "d. Business Benefit and Consequence of proposed Solution", key: "businessBenefit" },
      { title: "e. Assumptions", key: "assumptions" },
      { title: "f. Relationship to other documentation.", key: "relationshipToOtherDocumentation" },
    ];

    for (const s of overviewSections) {
      c.push(new Paragraph({ text: s.title, spacing: { before: 200 } }));
      const content = data[s.key] || "";
      c.push(...this._textBlockParagraphs(content));
    }

    // Functional Design
    c.push(this._heading("2. FunCtional Design", 2));
    // User Story block
    c.push(new Paragraph({ text: "a. User Story" }));
    if (data.userStories && data.userStories.length) {
      for (const us of data.userStories) {
        c.push(new Paragraph({ text: `${us.id ? `${us.id} - ` : ""}${us.title || ""}`, bullet: { level: 0 } }));
        c.push(...this._textBlockParagraphs(us.description || ""));
      }
    } else {
      c.push(...this._textBlockParagraphs(data.userStory || ""));
    }

    // Functional Design details
    c.push(new Paragraph({ text: "b. Functional Design" }));
    c.push(...this._textBlockParagraphs(data.functionalDesign || ""));

    // Constraints/Decisions
    c.push(new Paragraph({ text: "c. Constraints/Decisions" }));
    if (Array.isArray(data.constraints) && data.constraints.length) {
      for (const con of data.constraints) {
        c.push(new Paragraph({ text: `- ${con}`, bullet: { level: 0 } }));
      }
    } else {
      c.push(...this._textBlockParagraphs(data.constraintsText || ""));
    }

    // Delivery
    c.push(this._heading("3. Delivery", 2));
    c.push(new Paragraph({ text: "" }));

    // Tasks to be performed by SAP Ariba / Customer / Partner -> tables
    const deliveryBuckets = [
      { title: "Tasks to be performed by SAP Ariba", key: "tasksBySapAriba" },
      { title: "Tasks to be performed by <Customer>", key: "tasksByCustomer" },
      { title: "Tasks to be performed by <Partner>", key: "tasksByPartner" },
    ];

    for (const b of deliveryBuckets) {
      c.push(new Paragraph({ text: b.title }));
      const tasks = data[b.key] || [];
      if (tasks.length) {
        const header = new TableRow({
          children: ["Task", "Description", "Dependency"].map(h => new TableCell({ children: [new Paragraph({ text: h, bold: true })] })),
        });
        const rows = tasks.map(t => new TableRow({
          children: [
            new TableCell({ children: this._textBlockParagraphs(t.task || "") }),
            new TableCell({ children: this._textBlockParagraphs(t.description || "") }),
            new TableCell({ children: this._textBlockParagraphs(t.dependency || "") }),
          ]
        }));
        c.push(new Table({ rows: [header, ...rows], width: { size: 100, type: WidthType.PERCENTAGE } }));
      } else {
        c.push(...this._textBlockParagraphs(`No tasks provided for ${b.title}`));
      }
    }

    // Footer / Copyright block (taken from template)
    c.push(new Paragraph({ text: "" }));
    c.push(new Paragraph({ text: "www.sap.com/contactsap" }));
    c.push(new Paragraph({ text: "© 2018 SAP SE or an SAP affiliate company. All rights reserved." }));
    c.push(new Paragraph({ text: "" }));
    const docGen = new Document({
      creator: this.creator,
      title: "Project Functional Specification Document",
      description: "Generated functional specification document",
      sections: sections
    });
    // Pack and output
    const buffer = await Packer.toBuffer(docGen);
    // const filename2 = `output-files/Document-${Date.now()}.docx`;
    //     fs.writeFileSync(filename2, buffer);
    //     console.log(`Document created successfully: ${filename2}`);
    // if (outputPath) {
    //   const dir = path.dirname(outputPath);
    //   await fs.mkdir(dir, { recursive: true });
    //   await fs.writeFile(outputPath, buffer);
    // }
    return buffer;
  }
}
class DocGenerator {
  constructor(payloadOrArray = [], options = {}) {
    this.items = Array.isArray(payloadOrArray)
      ? payloadOrArray
      : [payloadOrArray];
    this.options = options;
    this.creator = options.creator || "Autogenerated by DocGenerator";
  }

  static _prettyBool(v) {
    return v === true || v === 1
      ? "Yes"
      : v === false || v === 0
      ? "No"
      : String(v);
  }

  _htmlToText(html) {
    return html
      .replace(/<[^>]+>/g, "")
      .replace(/\s+/g, " ")
      .trim();
  }
  _buildForItem(item) {
    const title = new Paragraph({
      children: [
        new TextRun({
          text: item.displayName || "Configuration Item",
          color: "2E74B5",
          bold: true,
          size: 32,
        }),
      ],
      heading: HeadingLevel.HEADING_2,
      alignment: AlignmentType.CENTER,
      spacing: { after: 200 },
    });

    const subtitle = new Paragraph({
      children: [new TextRun({ text: item.parameterName || "", bold: true })],
      alignment: AlignmentType.CENTER,
      spacing: { after: 240 },
    });

    const value = item.parameterValue;
    const valueText =
      value === true ? "ENABLED" : value === false ? "DISABLED" : String(value);
    const valueRun = new TextRun({
      text: valueText,
      bold: true,
      color: value === true ? "006400" : "8B0000",
    });
    const badge = new Paragraph({
      children: [
        new TextRun({ text: "Current value: ", italics: true }),
        valueRun,
      ],
      alignment: AlignmentType.CENTER,
      spacing: { after: 300 },
    });

    const description = new Paragraph({
      children: [
        new TextRun({ text: "Description:	", bold: true }),
        new TextRun({
          text: (this._htmlToText(item.description) || "-").slice(0, 1000),
        }),
      ],
      spacing: { after: 100 },
    });
    const inputPayload = {
      projectName: "Ariba Integration 1",
      customerName: "Acme Corp",
      customerProject: "ACME-Ariba-001",
      aribaSolution: "Services - Buy Channel",
      userStory: "As a user I want X so that Y",
      sapAribaPM: "John Ariba",
      customerPM: "Jane Customer",
      overview: {
        businessProcess:
          "We need to allow vendors to submit invoices via Ariba...",
        functionalOverview: "High-level functional changes include A, B, C.",
        alternatives: "Option 1: Use API; Option 2: Use manual import",
        benefits: "Reduce manual effort by 80%",
        assumptions: "Customer has existing Ariba instance",
        relations: "See Leading Practice Document LP-123",
      },
      revisionHistory: [
        {
          author: "Alice",
          docLocation: "repo/path/name",
          version: "0.1",
          status: "Draft",
          date: "01-Jan-2025",
          classification: "Internal",
        },
      ],
      functionalDesign: {
        userStories: "User story details here",
        designNotes: "Functional changes to RICEFWD objects",
        constraints: "No change to core Ariba APIs",
      },
      delivery: {
        sapTasks: [
          {
            task: "Develop integration",
            description: "Implement connector",
            dependency: "None",
          },
        ],
        customerTasks: [
          {
            task: "Provide sandbox",
            description: "Provision test system",
            dependency: "SAP tasks",
          },
        ],
        partnerTasks: [],
      },
    };
    // Table for properties
    const rows = [];
    rows.push(
      new TableRow({
        children: [
          new TableCell({
            width: { size: 40, type: WidthType.PERCENTAGE },
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
            shading: { fill: "F2F2F2" },
            children: [
              new Paragraph({
                children: [new TextRun({ text: "Property", bold: true })],
              }),
            ],
          }),
          new TableCell({
            width: { size: 60, type: WidthType.PERCENTAGE },
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
            shading: { fill: "F2F2F2" },
            children: [
              new Paragraph({
                children: [new TextRun({ text: "Value", bold: true })],
              }),
            ],
          }),
        ],
      })
    );

    function makeRow(prop, val) {
      return new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph({ text: prop })],
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
          }),
          new TableCell({
            children: [new Paragraph({ text: val })],
            margins: { top: 100, bottom: 100, left: 100, right: 100 },
          }),
        ],
      });
    }

    rows.push(makeRow("Parameter Type", item.parameterType || "-"));
    rows.push(makeRow("Is Default", DocGenerator._prettyBool(item.isDefault)));
    rows.push(
      makeRow("Default Value", DocGenerator._prettyBool(item.defaultValue))
    );
    rows.push(
      makeRow(
        "Is Customer Editable",
        DocGenerator._prettyBool(item.isCustomerEditable)
      )
    );
    rows.push(
      makeRow("Parameter Value", DocGenerator._prettyBool(item.parameterValue))
    );

    const detailsTable = new Table({
      rows,
      width: { size: 100, type: WidthType.PERCENTAGE },
      borders: {
        top: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        bottom: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        left: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        right: { style: BorderStyle.SINGLE, size: 1, color: "BFBFBF" },
        insideHorizontal: {
          style: BorderStyle.SINGLE,
          size: 1,
          color: "EDEDED",
        },
        insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "EDEDED" },
      },
      margin: { top: 200, bottom: 200 },
    });

    const note = new Paragraph({
      children: [
        new TextRun({ text: "Note: ", bold: true }),
        new TextRun({
          text: (this._htmlToText(item.description) || "-").slice(0, 1000),
        }),
      ],
      spacing: { before: 300 },
    });

    return { title, subtitle, badge, description, detailsTable, note };
  }

  async generateCombined(filename = "combined.docx") {
    const sections = [];

    const docChildren = [];

    this.items.forEach((item, idx) => {
      const built = this._buildForItem(item);

      if (idx !== 0) {
        docChildren.push(new Paragraph({ text: "", pageBreakBefore: false }));
      }

      docChildren.push(
        built.title,
        built.subtitle,
        built.badge,
        built.description,
        built.detailsTable
      );
    });

    const doc = new Document({
      creator: this.creator,
      title: this.options.title || "Configuration Document",
      description:
        this.options.description || "Generated configuration documentation",
      sections: [
        {
          properties: {},
          footers: {
            default: new Footer({
              children: [
                new Paragraph({
                  alignment: AlignmentType.CENTER,
                  children: [
                    new TextRun({
                      text: `Generated: ${new Date().toLocaleString()}`,
                    }),
                    new TextRun({ text: "  •  " }),
                    new TextRun({ text: "Page " }),
                    PageNumber.CURRENT,
                  ],
                }),
              ],
            }),
          },
          children: docChildren,
        },
      ],
    });

    // Packer.toBlob(doc)
    //   .then((blob) => {
    //     saveAs(blob, filename);
    //     console.log("Document created successfully");
    //     return filename;
    //   })
    //   .catch((err) => {
    //     console.error("Error creating document:", err);
    //   });
    // console.log("BUFFER", doc);
    const buffer = await Packer.toBuffer(doc);
    // let fileContent = fs.writeFileSync(filename, buffer);
    // console.log("Document created successfully", fileContent);

    return buffer;
  }

  async generateSeparate(outputDir = "output-files") {
    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const results = [];

    for (let i = 0; i < this.items.length; i++) {
      const item = this.items[i];

      const built = this._buildForItem(item);

      const doc = new Document({
        creator: this.creator,
        title: item.displayName || `Item ${i + 1}`,
        description: item.description || "",
        sections: [
          {
            properties: {},
            footers: {
              default: new Footer({
                children: [
                  new Paragraph({
                    alignment: AlignmentType.CENTER,
                    children: [
                      new TextRun({
                        text: `Generated: ${new Date().toLocaleString()}`,
                      }),
                      new TextRun({ text: "  •  " }),
                      new TextRun({ text: "Page " }),
                      PageNumber.CURRENT,
                    ],
                  }),
                ],
              }),
            },
            children: [
              built.title,
              built.subtitle,
              built.badge,
              built.description,
              built.detailsTable,
              built.note,
            ],
          },
        ],
      });

      const safeName = (item.parameterName || `item-${i + 1}`).replace(
        /[\/:*?"<>|]/g,
        "_"
      );
      const fname = path.join(outputDir, `${safeName}.docx`);
      const buffer = await Packer.toBlob(doc).then((blob) => {
        saveAs(blob, fname);
      });
      results.push(fname);
    }

    return results;
  }
}

module.exports = { DocGenerator, TemplateDocgenerator };


